{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-11-11T13:12:39.795Z","updated":"2021-11-11T13:12:39.795Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-11-11T13:12:39.796Z","updated":"2021-11-11T13:12:39.796Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2021-11-11T13:12:39.796Z","updated":"2021-11-11T13:12:39.796Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-11-11T14:38:17.544Z","updated":"2021-11-11T13:12:39.797Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-11-11T13:12:39.798Z","updated":"2021-11-11T13:12:39.798Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-11-11T13:12:39.797Z","updated":"2021-11-11T13:12:39.797Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-11-11T14:38:17.549Z","updated":"2021-11-11T13:12:39.797Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""}],"posts":[{"title":"JVM","slug":"JVM","date":"2021-11-11T15:41:31.908Z","updated":"2021-11-14T12:33:11.697Z","comments":true,"path":"2021/11/11/JVM/","link":"","permalink":"http://example.com/2021/11/11/JVM/","excerpt":"","text":"参考文档: 深入理解Java虚拟机：JVM高级特性与最佳实践（第3版） 周志明下载地址: https://pan.baidu.com/s/1U6yFeZxz9uD6sSiu-Br06g 提取码：3Wt4 编译器在JAVA10之前有两种执行子系统编译器,一种是是编译耗时短但输出代码优化程度较低的客户端编译器（简称为C1），一种是编译耗时长但输出代码优化质量也更高的服务端编译器（简称为C2）在JAVA10推出了另一种编译器,Graal编译器。而Graal编译器本身就是由Java语言写成，实现时又刻意与C2采用了同一种名为“Sea-of-Nodes”的高级中间表示（High IR）形式，使其能够更容易借鉴C2的优点。在保持输出相近质量的编译代码的同时，弥补了C2编译器效率慢的缺陷。在JAVA10中，NATIVE方向也发生了一些改变，例如面向用户类信息共享，在这个版本，它支持缓存用户程序代码，还有只做内存不做回收的垃圾回收器。这都是对提前编译的支持。提前编译的好处是是Java虚拟机加载这些已经预编译成二进制库之后就能够直接调用，而无须再等待即时编译器在运行时将其编译成二进制机器码。缺陷很明显，编译器是让机器识别的代码而运行的，必须为每个不同的硬件、操作系统去编译对应的发行包。为了解决这个问题，Substrate VM出现了，是在Graal VM 0.20版本里新出现的一个极小型的运行时环境，包括了独立的异常处理、同步调度、线程管理、内存管理（垃圾收集）和JNI访问等组件，目标是代替HotSpot用来支持提前编译后的程序执行。它还包含了一个本地镜像的构造器（Native Image Generator），用于为用户程序建立基于Substrate VM的本地运行时镜像。这个构造器采用指针分析（Points-To Analysis）技术，从用户提供的程序入口出发，搜索所有可达的代码。在搜索的同时，它还将执行初始化代码，并在最终生成可执行文件时，将已初始化的堆保存至一个堆快照之中。这样一来，Substrate VM就可以直接从目标程序开始运行，而无须重复进行Java虚拟机的初始化过程。但相应地，原理上也决定了Substrate VM必须要求目标程序是完全封闭的，即不能动态加载其他编译器不可知的代码和类库。基于这个假设，Substrate VM才能探索整个编译空间，并通过静态分析推算出所有虚方法调用的目标方法 JAVA内存运行时数据区域 红色代表线程共享方法区 虚拟机栈 本地方法栈 堆 程序计数器 执行引擎 本地库接口 本地方法库 程序计数器：当前线程所执行的字节码的行号指示器，通过它来选取下一条需要执行的字节码指令，是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域 OutOfMemoryError（堆溢出）：如果Java虚拟机栈容量可以动态扩展[2]，当栈扩展时无法申请到足够的内存StackOverflowError（栈溢出）：如果线程请求的栈深度大于虚拟机所允许的深度 Java虚拟机栈（Stack）：是Java方法执行的线程内存模型，Java虚拟机都会同步创建一个栈帧[1]（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程，HotSpot虚拟机的栈容量是不可以动态扩展的 局部变量表：它存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 本地方法栈（Native Method Stacks）：与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务 Java堆（Java Heap）：“所有的对象实例以及数组都应当在堆上分配，Java堆是垃圾收集器管理的内存区域，Java堆既可以被实现成固定大小的，也可以是可扩展的。 方法区（Method Area）：存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据，这个区域针对常量池的回收和对类型的卸载进行垃圾回收，这个区域存在常量池,常量池存放常量池表，常量池表用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中 直接内存（Method Area）：本机直接内存，避免在Java堆和Native堆中来回复制数据，样能在一些场景中显著提高性能，数据可以存储到直接内存中，本机直接虽然内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制 对象创建当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。在类加载检查通过后，接下来虚拟机将为新生对象分配内存。为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来指针碰撞：假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump ThePointer）空闲列表”（Free List）：但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录上述两种内存分配对象方式选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除（Sweep）算法的收集器时，理论上[1]就只能采用较为复杂的空闲列表来分配内存为对象分配内存空间两种方式都不是线程安全的，会发生不同指针指向都一个区域的情况，解决这种并发问题的两种方式:一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败试的方式保证更新操作的原子性。另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local AllocationBuffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。 对象内存布局对象头：一是存储对象自身运行的数据（如哈希码（HashCode） 25bit、GC分代年龄 4bit、锁状态标志 2bit、线程持有的锁、偏向线程ID、偏向时间戳），二是类型指针，指向类型元数据的指针。如果对象是一个数组，那必须有一个记录数组数据。实例数据：对象真正存储的有效信息（代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。这部分的存储顺序会受到虚拟机分配策略参数（-XX：FieldsAllocationStyle参数）和字段在Java源码中定义顺序的影响），顺序为:longs/doubles、ints、shorts/chars、bytes/booleans、oops（OrdinaryObject Pointers，OOPs填充位：对象的大小都必须是8字节的整数倍，由填充位来补全对象访问方式：一种是句柄，一种是直接指针。句柄是Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。直接指针访问是Java堆中对象的内存布局放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销 垃圾收集可达性分析算法中被回收的对象：在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等，·在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量，在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。在本地方法栈中JNI（即通常所说的Native方法）引用的对象。·Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。·所有被同步锁（synchronized关键字）持有的对象。·反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。引用定义：果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表某块内存、某个对象的引用强引用：指在程序代码之中普遍存在的引用赋值，即类似“Objectobj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。软引用（SoftReference）：来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常弱定义（WeakReference）：非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象虚定义（PhantomReference）：·虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知对象死亡过程：·要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。回收方法区：废弃的常量和不再使用的类型。回收废弃常量与回收。废弃常量回收满足条件：·该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。垃圾收集算法：引用计数式垃圾收集”（ReferenceCounting GC 直接垃圾收集）和“追踪式垃圾收集”（Tracing GC 间接垃圾收集）部分收集（Partial GC）：新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为·整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集标记-清除算法：简单来说，对引用的对象标记，再清楚没有标记的对象。缺陷就是，第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；第二个是内存空间的碎片化问题","categories":[],"tags":[]},{"title":"MySQL","slug":"MySQL","date":"2021-11-11T15:40:12.759Z","updated":"2021-11-11T15:41:02.669Z","comments":true,"path":"2021/11/11/MySQL/","link":"","permalink":"http://example.com/2021/11/11/MySQL/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"SpringCloud","slug":"SpringCloud","date":"2021-11-11T15:14:15.067Z","updated":"2021-11-11T15:18:16.586Z","comments":true,"path":"2021/11/11/SpringCloud/","link":"","permalink":"http://example.com/2021/11/11/SpringCloud/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"SpringBoot","slug":"SpringBoot","date":"2021-11-11T15:14:14.563Z","updated":"2021-11-11T15:17:57.475Z","comments":true,"path":"2021/11/11/SpringBoot/","link":"","permalink":"http://example.com/2021/11/11/SpringBoot/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Hadoop","slug":"Hadoop","date":"2021-11-11T15:14:14.030Z","updated":"2021-11-11T15:16:46.208Z","comments":true,"path":"2021/11/11/Hadoop/","link":"","permalink":"http://example.com/2021/11/11/Hadoop/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Elasticsearch","slug":"Elasticsearch","date":"2021-11-11T15:14:13.187Z","updated":"2021-11-11T15:16:01.182Z","comments":true,"path":"2021/11/11/Elasticsearch/","link":"","permalink":"http://example.com/2021/11/11/Elasticsearch/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Spring","slug":"Spring","date":"2021-11-11T15:14:12.142Z","updated":"2021-11-11T15:17:33.936Z","comments":true,"path":"2021/11/11/Spring/","link":"","permalink":"http://example.com/2021/11/11/Spring/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"JAVA","slug":"JAVA","date":"2021-11-11T15:09:46.948Z","updated":"2021-11-11T15:41:22.350Z","comments":true,"path":"2021/11/11/JAVA/","link":"","permalink":"http://example.com/2021/11/11/JAVA/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Hexo","slug":"hexo","date":"2021-11-09T17:15:42.881Z","updated":"2021-11-11T15:11:48.245Z","comments":true,"path":"2021/11/10/hexo/","link":"","permalink":"http://example.com/2021/11/10/hexo/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}